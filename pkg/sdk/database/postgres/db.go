package postgres

import (
	"context"
	"fmt"

	pgxdecimal "github.com/jackc/pgx-shopspring-decimal"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgxpool"
	pgxuuid "github.com/vgarvardt/pgx-google-uuid/v5"

	"github.com/indrasaputra/arjuna/pkg/sdk/uow"
)

var (
	postgresUniqueViolationCode = "23505"
	postgresConnFormat          = "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s"
)

var (
	// ErrNotFound is a sentinel error for not found error.
	ErrNotFound = pgx.ErrNoRows
)

// IsUniqueViolationError checks if the error is a unique violation error.
func IsUniqueViolationError(err error) bool {
	if err == nil {
		return false
	}
	if pgErr, ok := err.(*pgconn.PgError); ok {
		return pgErr.Code == postgresUniqueViolationCode
	}
	return false
}

// Config holds configuration for PostgreSQL.
type Config struct {
	Host     string `env:"POSTGRES_HOST,default=localhost"`
	User     string `env:"POSTGRES_USER,required"`
	Password string `env:"POSTGRES_PASSWORD,required"`
	Name     string `env:"POSTGRES_NAME,required"`
	SSLMode  string `env:"POSTGRES_SSL_MODE,default=disable"`
	Port     int    `env:"POSTGRES_PORT,default=5432"`
}

// NewPgxPool creates a new pgx pool.
func NewPgxPool(cfg Config) (*pgxpool.Pool, error) {
	connStr := fmt.Sprintf(postgresConnFormat,
		cfg.Host,
		cfg.Port,
		cfg.User,
		cfg.Password,
		cfg.Name,
		cfg.SSLMode,
	)
	connCfg, err := pgxpool.ParseConfig(connStr)
	if err != nil {
		return nil, err
	}
	connCfg.AfterConnect = func(_ context.Context, conn *pgx.Conn) error {
		pgxdecimal.Register(conn.TypeMap())
		pgxuuid.Register(conn.TypeMap())
		return nil
	}

	return pgxpool.NewWithConfig(context.Background(), connCfg)
}

// TxDB is a transaction version of DB interface generated by sqlc.
type TxDB struct {
	db       uow.Tr
	txGetter uow.TxGetter
}

// NewTxDB creates an instance of TxDB.
func NewTxDB(db uow.Tr, txGetter uow.TxGetter) *TxDB {
	return &TxDB{db: db, txGetter: txGetter}
}

// Exec runs Exec with transaction if needed.
func (d *TxDB) Exec(ctx context.Context, sql string, args ...interface{}) (pgconn.CommandTag, error) {
	tx := d.txGetter.DefaultTrOrDB(ctx, d.db)
	return tx.Exec(ctx, sql, args...)
}

// Query runs Query with transaction if needed.
func (d *TxDB) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) {
	tx := d.txGetter.DefaultTrOrDB(ctx, d.db)
	return tx.Query(ctx, sql, args...)
}

// QueryRow runs QueryRow with transaction if needed.
func (d *TxDB) QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row {
	tx := d.txGetter.DefaultTrOrDB(ctx, d.db)
	return tx.QueryRow(ctx, sql, args...)
}
